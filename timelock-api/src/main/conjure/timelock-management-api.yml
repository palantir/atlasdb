types:
  conjure-imports:
    api: timelock-api.yml
  definitions:
    default-package: com.palantir.atlasdb.timelock.api
    objects:
      DisableNamespacesRequest:
        fields:
          namespaces: set<api.Namespace>
          lockId: uuid
      SingleNodeUpdateResponse:
        fields:
          wasSuccessful: boolean
          # other namespaces will not have been disabled/re-enabled (the transaction will not complete)
          lockedNamespaces: map<api.Namespace, uuid>
      SuccessfulDisableNamespacesResponse:
        fields:
          lockId: uuid
      UnsuccessfulDisableNamespacesResponse:
        fields:
          # we can assume another restore is in progress for this namespace
          consistentlyDisabledNamespaces: set<api.Namespace>
          # either another restore is in progress for this namespace (and we've hit a race condition), or
          # the namespace is stuck and needs to be manually fixed.
          partiallyDisabledNamespaces: set<api.Namespace>
      DisableNamespacesResponse:
        union:
          successful: SuccessfulDisableNamespacesResponse
          unsuccessful: UnsuccessfulDisableNamespacesResponse
      ReenableNamespacesRequest:
        fields:
          namespaces: set<api.Namespace>
          lockId: uuid
      SuccessfulReenableNamespacesResponse:
        alias: boolean
      UnsuccessfulReenableNamespacesResponse:
        fields:
          # we can assume another restore is in progress for this namespace (we lost our lock)
          consistentlyLockedNamespaces: set<api.Namespace>
          # either another restore is in progress for this namespace (and we lost our lock), or
          # the namespace is stuck and needs to be manually fixed.
          partiallyLockedNamespaces: set<api.Namespace>
      ReenableNamespacesResponse:
        union:
          successful: SuccessfulReenableNamespacesResponse
          unsuccessful: UnsuccessfulReenableNamespacesResponse

services:
  DisabledNamespacesUpdaterService:
    name: Internal updater service, for propagating disabled namespace updates across nodes.
    default-auth: header
    package: com.palantir.atlasdb.timelock.api
    base-path: /dn
    endpoints:
      ping:
        http: GET /ping
        returns: boolean
      disable:
        http: POST /disable
        args:
          request: DisableNamespacesRequest
        returns: SingleNodeUpdateResponse
      reenable:
        http: POST /reenable
        args:
          request: ReenableNamespacesRequest
        returns: SingleNodeUpdateResponse
  TimeLockManagementService:
    name: TimeLock Management Service
    default-auth: header
    package: com.palantir.atlasdb.timelock.api.management
    base-path: /tl/management
    endpoints:
      getNamespaces:
        http: POST /getNamespaces
        returns: set<string>
        docs: |
          The endpoint loads all persisted namespaces. ``leaderPaxos`` is filtered out from the set
          as it is not a namespace.

      achieveConsensus:
        http: POST /achieveConsensus
        args:
          namespaces: set<string>
        docs: |
          The operation of achieving consensus on all namespaces is NOT atomic. In the case of failures, it can
          be assumed that consensus was achieved on some namespaces.

      invalidateResources:
        http: POST /invalidateResources
        args:
          namespaces: set<string>
        docs: |
          Invalidates existing resources for a given TimeLock namespace in a persistant way, until re-enabled. Does not
          actually cause a leader election, and should not interrupt service for other naemspaces. Note that this
          operation is atomic for each namespace (e.g. users will not see two different lock services servicing the
          same startTransactions request), but not atomic as a whole. Additionally, if this method throws, it is
          nondeterministic which, if any, namespaces have been invalidated; some may even be invalidated only on a
          subset of nodes. This state can be cleared by re-enabling all namespaces.

      getServerLifecycleId:
        http: POST /getServerLifecycleId
        returns: uuid
        docs: |
          Gets the randomly generated server id associated with the server's current lifecycle upon start up.

      forceKillTimeLockServer:
        http: POST /forceKillTimeLockServer
        returns: uuid
        docs: |
          Kills TimeLock server asynchronously i.e. current server will not be able to talk to
          peer nodes or serve requests once the task is executed. After hitting this endpoint, the server will require
          external intervention to start up the service again. The endpoint returns the (randomly generated) server id
          associated with server upon start up. A client can then make `getServerId` requests wherein change in
          server id would imply that the server was bounced.
