

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Performance Ideas &mdash; OSS AtlasDB develop documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/release-notes.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Transaction Protocol" href="transaction_protocol.html" />
    <link rel="prev" title="Isolation Levels" href="isolation_levels.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> OSS AtlasDB
          

          
          </a>

          
            
            
              <div class="version">
                develop
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../schemas/index.html">Schemas</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Transactions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="isolation_levels.html">Isolation Levels</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Performance Ideas</a></li>
<li class="toctree-l2"><a class="reference internal" href="transaction_protocol.html">Transaction Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="life_of_a_transaction.html">Life of a Transaction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../configuration/index.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cluster_management/index.html">Cluster Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../services/index.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance/index.html">Performance Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../miscellaneous/index.html">Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting/index.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes/index.html">Releases</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OSS AtlasDB</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Transactions</a> &raquo;</li>
        
      <li>Performance Ideas</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/palantir/atlasdb/blob/develop/docs/source/transactions/performance_ideas.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="performance-ideas">
<h1>Performance Ideas<a class="headerlink" href="#performance-ideas" title="Permalink to this headline">¶</a></h1>
<section id="intended-use">
<h2>Intended Use<a class="headerlink" href="#intended-use" title="Permalink to this headline">¶</a></h2>
<p>AtlasDB is designed to be an OLTP distributed transactional DB. This
means that it is good at writing small chunks of work very quickly with
full ACID support. Below are some ideas of how to design your write path
to get the most out of AtlasDB.</p>
</section>
<section id="short-lived-writes">
<h2>Short-Lived Writes<a class="headerlink" href="#short-lived-writes" title="Permalink to this headline">¶</a></h2>
<p>A long lived writing transaction may cause problems in the following
cases</p>
<ul class="simple">
<li><p>Consistent backups cannot advance past the start time of this
transaction</p></li>
<li><p>If we do any sort of cross data center replication it can’t advance
past this open transaction</p></li>
<li><p>We may be doing a bunch of work that will be rolled back at commit
time due to a write/write conflict</p></li>
<li><p>If you grabbed locks before starting the transaction, other users
could be blocking on these locks</p></li>
<li><p>Our locks may have timed out and we won’t find out until commit time
and have to retry all this work</p></li>
</ul>
<p>The general theme here is that you are blocking others and you may have
to be rolled back and redo all the work. AtlasDB just buffers up writes
and doesn’t check for conflicts/expired locks until commit time. If your
transaction takes tens of seconds, it’s time to break it up.</p>
</section>
<section id="advisory-locking-prevents-write-write-conflicts">
<h2>Advisory Locking Prevents Write/Write Conflicts<a class="headerlink" href="#advisory-locking-prevents-write-write-conflicts" title="Permalink to this headline">¶</a></h2>
<p>If you want to ensure that your transaction doesn’t run into a conflict
then advisory locking is for you. The main reason you would want this is
when the input into your transaction is not immutable. An example of
this is working with legacy code and migrating to use AtlasDB. This is
bad design for sure, but instead of having to fix all the code that
might change the input, we can just use advisory locking to ensure that
we won’t need to roll back this transaction.</p>
<p>AtlasDB has lock checking built into its
<a class="reference external" href="AtlasDB-Transaction-Protocol">protocol</a>. This means that you can do
your own locking, then pass those locks to
<code class="docutils literal notranslate"><span class="pre">LockAwareTransactionManager.runTaskWithLock(...)</span></code>. If your
transaction commits successfully this means that no other transaction
concurrently held these locks and committed successfully. (Concurrently
means that either your commitTs falls between their startTs and commitTs
or vice versa)</p>
</section>
<section id="limit-write-size">
<h2>Limit Write Size<a class="headerlink" href="#limit-write-size" title="Permalink to this headline">¶</a></h2>
<p>The entirety of the write set is buffered in memory before you commit.
You will trigger warn and error logging at 10MB and 100MB respectively
if you write too much data. If you keep a transaction under 10MB, you
should be good to go.</p>
</section>
<section id="limit-row-size">
<h2>Limit Row Size<a class="headerlink" href="#limit-row-size" title="Permalink to this headline">¶</a></h2>
<p>Every row should be able to be loaded into memory. A good rule of thumb
is to make sure that no row will be bigger than 10MB. If you imagine
that your rows will become bigger than this then you should maybe use
range scans instead of dynamic columns to store your data. This is the
total row size across all the cells possibly stored in many different
transactions.</p>
</section>
<section id="prefilter-columns-when-possible">
<h2>Prefilter Columns When Possible<a class="headerlink" href="#prefilter-columns-when-possible" title="Permalink to this headline">¶</a></h2>
<p>When we query the underlying data store for a getRow call for a named
table, usually we issue a bunch of getCell calls instead for each column
name in the table. getCell usually has to load less data off disk so
this is an IO optimization. This means that if you don’t actually expect
those cells to be there, you should restrict the columns you are
selecting by using a ColumnSelection.</p>
</section>
<section id="lookups-may-be-faster-than-range-scans">
<h2>Lookups May Be Faster Than Range Scans<a class="headerlink" href="#lookups-may-be-faster-than-range-scans" title="Permalink to this headline">¶</a></h2>
<p>Some data stores have optimizations for doing an explicit lookup of a
row name like using bloom filters. These bloom filters are useless when
doing a range scan. This means that you may have to do more disk reads
to do a range scan than a lookup.</p>
</section>
<section id="highly-overwritten-dynamic-columns-need-garbage-collection">
<h2>Highly Overwritten Dynamic Columns Need Garbage Collection<a class="headerlink" href="#highly-overwritten-dynamic-columns-need-garbage-collection" title="Permalink to this headline">¶</a></h2>
<p>This one is a little tricky to explain. On some data stores
(hem…Cassandra…hmm) loading a row for a dynamic table basically
means loading the whole row across all history. This means that if you
do a lot of overwrites, you will be loading old values off disk and then
filtering them away. If you minimize overwrites (or you clean up old
values frequently) then you can avoid this extra I/O.</p>
</section>
<section id="snapshot-isolation">
<h2>Snapshot Isolation<a class="headerlink" href="#snapshot-isolation" title="Permalink to this headline">¶</a></h2>
<p>This isn’t a performance consideration, but is worth noting that
snapshot isolation only detects and throws on WRITE/WRITE conflicts.
This means that if you need to ensure that a value has not changed, you
have to “touch”it. Basically read its value and write it back. This is
called “materializing” the conflict.</p>
<p>This also means that you can’t detect someone adding a cell. Let’s say
you are trying to delete all the rows between 100 and 1000 and the only
row there is 500. So you do a read for all the stuff between 100 and
1000 and you get back 500 and delete it. Another transaction could be
concurrently writing 600 and you won’t be able to detect it. The final
state of the world after you are done is not “everything between 100 and
1000 is deleted” like you expected.</p>
<p>This can be fixed by using Serializable, but note this also comes with a
performance penalty. When detecting write/write conflict, we need to do
reads on the “write set” at commit time. When detecting read/write
conflicts we need to also do another set of reads on our “read set” to
ensure they are all still the same. This also means our read set needs
to fit in memory because we need to keep track of everything to ensure
it’s the same.</p>
<p>Basically, you need to think about the types of queries you want to run
and what your invariants are. Then you need to enforce these invariants
using “materialized conflicts” or “advisory locking” or Serializable
depending on which is best for you.</p>
</section>
<section id="transactions-should-have-immutable-inputs">
<h2>Transactions Should Have Immutable Inputs<a class="headerlink" href="#transactions-should-have-immutable-inputs" title="Permalink to this headline">¶</a></h2>
<p>If your input is immutable it means that your transaction can be retried
easily. This is just good programming practice and ensures you are using
transactions correctly. If you are porting legacy code and this isn’t
possible then see above section about advisory locking.</p>
</section>
<section id="ignore-conflicts-when-possible">
<h2>Ignore Conflicts When Possible<a class="headerlink" href="#ignore-conflicts-when-possible" title="Permalink to this headline">¶</a></h2>
<p>The cost of doing conflict detection is an extra read done at commit
time to ensure that no one has written a newer value to that cell.</p>
<p>Here is an example of where I can safely use IGNORE_ALL. Let’s say that
whenever I write to table A I also write a row in table B which is an
index on A. I don’t need write/write conflicts on the index because the
every time there is a conflict on B, there is also a conflict on A. So I
can just use <code class="docutils literal notranslate"><span class="pre">TableConflictHandler.RETRY_ON_WRITE_WRITE</span></code> for A, and
<code class="docutils literal notranslate"><span class="pre">IGNORE_ALL</span></code> for table B.</p>
</section>
<section id="tombstones-and-range-scans">
<h2>Tombstones and Range Scans<a class="headerlink" href="#tombstones-and-range-scans" title="Permalink to this headline">¶</a></h2>
<p>Since each delete is a tombstone that lives in the db if a table
contains 99% deletes then range queries will have to keep paging through
these deleted values before it finds any non-deleted values. This may
mean that simple index lookups become full table scans (This includes
range queries like isEmpty).</p>
<p>This is especially painful if you are iterating over a table from the
beginning and deleting values as you process them. This causes n^2
behavior because you have to scan past all deleted values before you
find new values for each page. This is similar to the sql performance
bug where you use <em>limit</em> and <em>offset</em> on an <em>order by</em> query that
doesn’t have an index with that order.</p>
<p>We may allow removing sufficiently old tombstones at some point in the
future, but this is not currently planned.</p>
</section>
<section id="conflict-detection">
<h2>Conflict Detection<a class="headerlink" href="#conflict-detection" title="Permalink to this headline">¶</a></h2>
<p>Conflicts are at the cell level, but write locking is at the row level
Normally lock contention in atlasdb is very low. If two transactions
write to the same cell there will be a small amount of lock contention
for the 2nd transaction and it will be rolled back. However, if you have
many clients writing to different cells in the same row, they will
experience the same lock contention, but no write/write conflict.</p>
<p>Avoid designs where you expect multiple clients to write into the same
row but different cells.</p>
<hr class="docutils" />
<p>Note: It is a good practice to call <code class="docutils literal notranslate"><span class="pre">TransactionManager.close()</span></code> to
free up the underlying resources when you intend to no longer run transactions.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="transaction_protocol.html" class="btn btn-neutral float-right" title="Transaction Protocol" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="isolation_levels.html" class="btn btn-neutral float-left" title="Isolation Levels" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2017, Palantir Technologies.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>